https://vjudge.net/contest/310214#problem/A
有一个长方形的房间，上面铺着正方形的瓷砖。
每块瓷砖都是红色或黑色的。一个男人站在一块黑色的瓷砖上。
从一个瓦片，他可以移动到四个相邻瓦片中的一个。但是他不能在红瓦上移动，他只能在黑瓦上移动。
编写一个程序，通过重复上面描述的动作来计算他可以到达的黑色方块的数量。
输入输入由多个数据集组成。
数据集以包含两个正整数W和H的行开始;W和H分别是x和y方向上的瓦片数。
W和H不超过20。数据集中还有H多行，每一行都包含W个字符。
每个字符表示一个tile的颜色，如下所示。
”。——一块黑瓷砖“#”——红色瓷砖@——一个男人在黑色的平铺上(数据集中只出现一次)
输出对于每个数据集，程序应该输出一行，其中包含从初始块(包括它本身)可以到达的块的数量。
Sample Input
6 9
....#.
.....#
......
......
......
......
......
#@...#
.#..#.
11 9
.#.........
.#.#######.
.#.#.....#.
.#.#.###.#.
.#.#..@#.#.
.#.#####.#.
.#.......#.
.#########.
...........
11 6
..#..#..#..
..#..#..#..
..#..#..###
..#..#..#@.
..#..#..#..
..#..#..#..
7 7
..#.#..
..#.#..
###.###
...@...
###.###
..#.#..
..#.#..
0 0
Sample Output
45
59
6
13
#include<cstdio>
#include<iostream>
using namespace std;
char a[100][100];
int i,j,sum,n,m;
void dfs(int i,int j)
{
	if(i<0||i>=n||j<0||j>=m||a[i][j]=='#')//边界问题的处理 
		return ;
		sum++;
		a[i][j]='#';//标记这个点已经走过了 
		dfs(i+1,j);dfs(i-1,j);dfs(i,j+1);dfs(i,j-1);//深搜这个点的四个方向	
}
int main()
{
	
	while(scanf("%d %d",&m,&n)!=EOF)
	{
		if(n==0&&m==0)
		{
			break;
		}
		else
		{
			for(i=0;i<n;i++)
			{
				for(j=0;j<m;j++)
				{
					cin>>a[i][j];
				}
			}
			sum=0;
			for(i=0;i<n;i++)
			{
				for(j=0;j<m;j++)
				{
					if(a[i][j]=='@')
					{
					   dfs(i,j);	
					}
				}
			}
		  printf("%d\n",sum);
		}
	
	}
}
解题思路：
裸深搜问题，判断边界后进行深搜，要记得标记已经走过的点。
